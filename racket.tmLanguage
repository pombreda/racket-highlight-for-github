# [PackageDev] target_format: plist, ext: tmLanguage
---
##Parsing YAML... (/Users/soegaard/Library/Application Support/Sublime Text 3/Packages/User/racket.YAML-tmLanguage)
##Writing Property List... (/Users/soegaard/Library/Application Support/Sublime Text 3/Packages/User/racket.tmLanguage)
##[Finished in 0.011s]

# name of the programming language
name: Racket (soegaard)
# the name of the top level scope
scopeName: source.racket
# list of file extensions without the leading dot
fileTypes: [rkt]
# An unique identifier for this syntax definition.
uuid: c5160d97-e918-473b-a594-3d22afffc0a7




patterns:
# comment - optional comment about patterns
# name    - the name of the scope
# match   - a regular expression (in Onigurama syntax - sigh)


###
### DELIMITERS
###

# The Racket delimiters are matched by the expression [()\[\]{}",'`;\ \s]
# In most situation we want a match to stop at a delimiter, but the
# actual delimiter is not part of the match. The syntax for this is:
#      (?=[()\[\]{}",'`;\ \s])

###
### DATUMS
###


- comment: string datums  are enclosed in ". Inside a string \" is used to escape an ".
  name: string.quoted.double
  match: \"([^"])*\"


- comment: booleans #t,#f, #true, or #false followed by a delimiter  (capture the first parenthesis to remove the delimiter)
  name: string.quoted.double
  match: ((\#[tT])|(\#[fF])|(\#true)|(\#false))(?=[()\[\]{}",'`;\ \s])

- comment: character datum
  name: string.quoted.double
  match: \#\\[A-Za-z]([A-Za-z])*


- comment: real - an optional sign followed by a number with a period
  name:    string.quoted.double
  match:   (([+\-]?)(([0-9])++)\.([0-9])*)(?=[()\[\]{}",'`;\ \s])

- comment: rationals - with an optional sign
  name:    string.quoted.double
  match:   ((([+\-]?)([0-9])++)/([0-9])++)(?=[()\[\]{}",'`;\ \s])

- comment: integers - with an optional sign
  name:    string.quoted.double
  match:   (([+\-]?)([0-9])++)(?=[()\[\]{}",'`;\ \s])

- comment: void
  name: string.quoted.double
  match: \#void(?=[()\[\]{}",'`;\ \s])

- comment: symbol
  name: string.quoted.double
  match: \'([^#()\[\]{}",'`; \s]([^()\[\]{}",'`;\ \s])*)

 # todo: quoted s-expressions ?

- comment: quoted empty list
  name: string.quoted.double
  match: \'\(\)

- comment: keyword
  name: string.quoted.double
  match: \#\:([^#()\[\]{}",'`; \s]([^()\[\]{}",'`;\ \s])*)

- comment: syntax-quoted identifiers   #'name
  name: string.quoted.double
  match: \#\'([^#()\[\]{}",'`; \s]([^()\[\]{}",'`;\ \s])*)

###
### IDENTIFIERS
###

- comment: syntax in the racket language
  name:    string.quoted.double
  match:  (\#\%app|\#\%datum|\#\%declare|\#\%expression|\#\%module\-begin|\#\%plain\-app|\#\%plain\-lambda|\#\%plain\-module\-begin|\#\%printing\-module\-begin|\#\%provide|\#\%require|\#\%stratified\-body|\#\%top|\#\%top\-interaction|\#\%variable\-reference|\->|\->\*|\->\*m|\->d|\->dm|\->i|\->m|\.\.\.|\:do\-in|==|=>|_|absent|abstract|all\-defined\-out|all\-from\-out|and|any|augment|augment\*|augment\-final|augment\-final\*|augride|augride\*|begin|begin\-for\-syntax|begin0|case|case\->|case\->m|case\-lambda|class|class\*|class\-field\-accessor|class\-field\-mutator|class/c|class/derived|combine\-in|combine\-out|command\-line|compound\-unit|compound\-unit/infer|cond|contract|contract\-out|contract\-struct|contracted|define|define\-compound\-unit|define\-compound\-unit/infer|define\-contract\-struct|define\-custom\-hash\-types|define\-custom\-set\-types|define\-for\-syntax|define\-local\-member\-name|define\-logger|define\-match\-expander|define\-member\-name|define\-module\-boundary\-contract|define\-namespace\-anchor|define\-opt/c|define\-sequence\-syntax|define\-serializable\-class|define\-serializable\-class\*|define\-signature|define\-signature\-form|define\-struct|define\-struct/contract|define\-struct/derived|define\-syntax|define\-syntax\-rule|define\-syntaxes|define\-unit|define\-unit\-binding|define\-unit\-from\-context|define\-unit/contract|define\-unit/new\-import\-export|define\-unit/s|define\-values|define\-values\-for\-export|define\-values\-for\-syntax|define\-values/invoke\-unit|define\-values/invoke\-unit/infer|define/augment|define/augment\-final|define/augride|define/contract|define/final\-prop|define/match|define/overment|define/override|define/override\-final|define/private|define/public|define/public\-final|define/pubment|define/subexpression\-pos\-prop|delay|delay/idle|delay/name|delay/strict|delay/sync|delay/thread|do|else|except|except\-in|except\-out|export|extends|failure\-cont|false|false/c|field|field\-bound\?|file|flat\-murec\-contract|flat\-rec\-contract|for|for\*|for\*/and|for\*/first|for\*/fold|for\*/fold/derived|for\*/hash|for\*/hasheq|for\*/hasheqv|for\*/last|for\*/list|for\*/lists|for\*/mutable\-set|for\*/mutable\-seteq|for\*/mutable\-seteqv|for\*/or|for\*/product|for\*/set|for\*/seteq|for\*/seteqv|for\*/sum|for\*/vector|for\*/weak\-set|for\*/weak\-seteq|for\*/weak\-seteqv|for\-label|for\-meta|for\-syntax|for\-template|for/and|for/first|for/fold|for/fold/derived|for/hash|for/hasheq|for/hasheqv|for/last|for/list|for/lists|for/mutable\-set|for/mutable\-seteq|for/mutable\-seteqv|for/or|for/product|for/set|for/seteq|for/seteqv|for/sum|for/vector|for/weak\-set|for/weak\-seteq|for/weak\-seteqv|gen\:custom\-write|gen\:dict|gen\:equal\+hash|gen\:set|gen\:stream|generic|get\-field|if|implies|import|include|include\-at/relative\-to|include\-at/relative\-to/reader|include/reader|inherit|inherit\-field|inherit/inner|inherit/super|init|init\-depend|init\-field|init\-rest|inner|inspect|instantiate|interface|interface\*|invariant\-assertion|invoke\-unit|invoke\-unit/infer|lambda|lazy|let|let\*|let\*\-values|let\-syntax|let\-syntaxes|let\-values|let/cc|let/ec|letrec|letrec\-syntax|letrec\-syntaxes|letrec\-syntaxes\+values|letrec\-values|lib|link|local|local\-require|log\-debug|log\-error|log\-fatal|log\-info|log\-warning|match|match\*|match\*/derived|match\-define|match\-define\-values|match\-lambda|match\-lambda\*|match\-lambda\*\*|match\-let|match\-let\*|match\-let\*\-values|match\-let\-values|match\-letrec|match/derived|match/values|member\-name\-key|method\-contract\?|mixin|module|module\*|module\+|nand|new|nor|object\-contract|object/c|only|only\-in|only\-meta\-in|open|opt/c|or|overment|overment\*|override|override\*|override\-final|override\-final\*|parameterize|parameterize\*|parameterize\-break|parametric\->/c|place|place\*|planet|prefix|prefix\-in|prefix\-out|private|private\*|prompt\-tag/c|protect\-out|provide|provide\-signature\-elements|provide/contract|public|public\*|public\-final|public\-final\*|pubment|pubment\*|quasiquote|quasisyntax|quasisyntax/loc|quote|quote\-syntax|quote\-syntax/prune|recontract\-out|recursive\-contract|relative\-in|rename|rename\-in|rename\-inner|rename\-out|rename\-super|require|send|send\*|send\+|send\-generic|send/apply|send/keyword\-apply|set!|set!\-values|set\-field!|shared|stream|stream\-cons|struct|struct\*|struct\-copy|struct\-field\-index|struct\-out|struct/c|struct/ctc|struct/dc|submod|super|super\-instantiate|super\-make\-object|super\-new|syntax|syntax\-case|syntax\-case\*|syntax\-id\-rules|syntax\-rules|syntax/loc|tag|this|this\%|thunk|thunk\*|time|unconstrained\-domain\->|unit|unit\-from\-context|unit/c|unit/new\-import\-export|unit/s|unless|unquote|unquote\-splicing|unsyntax|unsyntax\-splicing|values/drop|when|with\-continuation\-mark|with\-contract|with\-handlers|with\-handlers\*|with\-method|with\-syntax|Î»)(?=[()\[\]{}",'`;\ \s])
  captures: 
    '1': {name: string.quoted.double}





# Identifiers start with a non-delimiter different from #
# The identifier continues until a delimiter is seen.
- comment: identifiers
  name: variable
  match: ([^#()\[\]{}",'`; \s]([^()\[\]{}",'`;\ \s])*)


###
### COMMENTS
###

- comment: #; comments - color the #;  (todo: color the following s-exp)
  name: comment.sexp
  match: \#\;

# line comment
- comment: ; comments begins with ; and extends to the end of the line
  name: comment.line.semicolon
  match: ;.*$

# use two spaces for indentation - yaml syntax is indentation 
#- comment: Tab stops like $1, $2...
#  name: keyword.other.racket
# match: \$\d+

#- comment: Variables like $PARAM1, $TM_SELECTION
#  name: keyword.other.racket


# Capture groups are numbered 
#   - this makes its possible to color different parts of a match in different colors
#   - the capture group 0 refers to the whole match

#- comment: Variables like $PARAM1, $TM_SELECTION
#  name: keyword.other.racket
#  match: \$([A-Za-z][A-Za-z0-9_]+)
#  captures:
#    '1': {name: constant.numeric.racket}




